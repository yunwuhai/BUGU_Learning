/*************************************************************************************
 * @Description  : 
 * @Version      : 
 * @Author       : YunWuHai
 * @Date         : 2021-06-02 14:09:00
 * @LastEditors  : YunWuHai
 * @LastEditTime : 2021-06-05 12:17:29
 * @FilePath     : \VS1053\HAL_VS10xx.c
 * @Copyright (C) 2021 YunWuHai. All rights reserved.
 *************************************************************************************/
#include "HAL_VS10xx.h"

_vs10xx_obj vsset=
{
	220,	//音量:220
	6,		//低音上线 60Hz
	15,		//低音提升 15dB	
	10,		//高音下限 10Khz	
	15,		//高音提升 10.5dB
	0,		//空间效果	
	1,		//板载喇叭默认打开.
};

#define delay_ms(x) HAL_Delay(x)


/*************************************************************************************
 * @description: 读写一字节 
 * @param {uint8_t} txData 需要发送的数据
 * @return {*} 接受到一字节的数据
 *************************************************************************************/
uint8_t VS_SPI_ReadWriteByte(uint8_t txData)
{
    uint8_t rxData;
    return HAL_SPI_TransmitReceive(&VS_SPI_PORT, &txData, &rxData, 1, 0xFFFF);
}
volatile uint8_t nes_spped_para=0;			//NES游戏进行时,将会对此值设置,默认为0.

/*************************************************************************************
 * @description: 设置SPI速度
 * @param {uint32_t} baud
 * @return {*}
 *************************************************************************************/
static void SPI_SetSpeed(uint32_t baud)
{
    assert_param(IS_SPI_BAUDRATE_PRESCALER(baud));
	VS_SPI_PORT.Instance->CR1&=0xFFFFFFC7;
	VS_SPI_PORT.Instance->CR1|=baud;
    __HAL_SPI_ENABLE(&VS_SPI_PORT);
}

/*************************************************************************************
 * @description: SD卡初始化的时候,需要低速
 * @param {*}
 * @return {*}
 *************************************************************************************/
void VS_SPI_SpeedLow(void)
{								 
	SPI_SetSpeed(SPI_BAUDRATEPRESCALER_32);//设置到低速模式 
}

/*************************************************************************************
 * @description: SD卡正常工作的时候,可以高速了
 * @param {*}
 * @return {*}
 *************************************************************************************/
void VS_SPI_SpeedHigh(void)
{						  
	SPI_SetSpeed(SPI_BAUDRATEPRESCALER_8);//设置到高速模式		 
}

void VS_Init(void)
{
	VS_RST_Set();
	VS_XCS_Set();
	VS_XDCS_Set();
	VS_HD_Reset();
}
/*************************************************************************************
 * @description: 软复位
 * @param {*}
 * @return {*}
 *************************************************************************************/
void VS_Soft_Reset(void)
{
    uint8_t retry = 0;
	while(VS_RD_Reg(SPI_MODE)!=0x0800)	// 软件复位,新模式  
	{
		VS_WR_Cmd(SPI_MODE,0x0804);		// 软件复位,新模式	    
		delay_ms(2);//等待至少1.35ms 
		if(retry++>100)break; 	    
	}	 		 
    VS_DQ_Wait();
    retry = 0;
	while(VS_RD_Reg(SPI_CLOCKF)!=0X9800)//设置VS10XX的时钟,3倍频 ,1.5xADD 
	{
		VS_WR_Cmd(SPI_CLOCKF,0X9800);	//设置VS10XX的时钟,3倍频 ,1.5xADD
		if(retry++>100)break; 	    
	}	
	delay_ms(20);
}

/*************************************************************************************
 * @description: 硬复位MP3
 * @param {*}
 * @return {uint8_t} 1:复位失败;0:复位成功	   
 *************************************************************************************/
uint8_t VS_HD_Reset(void)
{
    uint8_t retry = 0;
    VS_RST_Clr();
    delay_ms(20);
    VS_XDCS_Set();
    VS_XCS_Set();
    VS_RST_Set();
    while(VS_DQ_Read() == GPIO_PIN_RESET && retry < 200)
    {
        retry++;
        delay_us(50);
    }
    delay_ms(20);
    if(retry >= 200) return 1;
    else return 0;
}

/*************************************************************************************
 * @description: 正弦测试
 * @param {*}
 * @return {*}
 *************************************************************************************/
void VS_Sine_Test(void)
{											    
	VS_HD_Reset();	 
	VS_WR_Cmd(0x0b,0X2020);	  //设置音量	 
 	VS_WR_Cmd(SPI_MODE,0x0820);//进入VS10XX的测试模式     
	VS_DQ_Wait();     //等待DREQ为高
  	VS_SPI_SpeedLow();//低速 
	VS_XDCS_Clr();//选中数据传输
	VS_SPI_ReadWriteByte(0x53);
	VS_SPI_ReadWriteByte(0xef);
	VS_SPI_ReadWriteByte(0x6e);
	VS_SPI_ReadWriteByte(0x24);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	delay_ms(100);
	VS_XDCS_Set(); 
    //退出正弦测试
    VS_XDCS_Clr();//选中数据传输
	VS_SPI_ReadWriteByte(0x45);
	VS_SPI_ReadWriteByte(0x78);
	VS_SPI_ReadWriteByte(0x69);
	VS_SPI_ReadWriteByte(0x74);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	delay_ms(100);
	VS_XDCS_Set();		 

    //再次进入正弦测试并设置n值为0x44，即将正弦波的频率设置为另外的值
    VS_XDCS_Clr();//选中数据传输      
	VS_SPI_ReadWriteByte(0x53);
	VS_SPI_ReadWriteByte(0xef);
	VS_SPI_ReadWriteByte(0x6e);
	VS_SPI_ReadWriteByte(0x44);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	delay_ms(100);
 	VS_XDCS_Set();
    //退出正弦测试
    VS_XDCS_Clr();//选中数据传输
	VS_SPI_ReadWriteByte(0x45);
	VS_SPI_ReadWriteByte(0x78);
	VS_SPI_ReadWriteByte(0x69);
	VS_SPI_ReadWriteByte(0x74);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	delay_ms(100);
	VS_XDCS_Set();	 
}

/*************************************************************************************
 * @description: RAM测试
 * @param {*}
 * @return {uint16_t}RAM测试结果
 *************************************************************************************/
uint16_t VS_Ram_Test(void)
{
	VS_HD_Reset();     
 	VS_WR_Cmd(SPI_MODE,0x0820);// 进入VS10XX的测试模式
	VS_DQ_Wait();		   
 	VS_SPI_SpeedLow();//低速 
	VS_XDCS_Clr();	       		    // xDCS = 1，选择VS10XX的数据接口
	VS_SPI_ReadWriteByte(0x4d);
	VS_SPI_ReadWriteByte(0xea);
	VS_SPI_ReadWriteByte(0x6d);
	VS_SPI_ReadWriteByte(0x54);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	VS_SPI_ReadWriteByte(0x00);
	delay_ms(150);  
	VS_XDCS_Set();
	return VS_RD_Reg(SPI_HDAT0);// VS1003如果得到的值为0x807F，则表明完好;VS1053为0X83FF.; 
}

/*************************************************************************************
 * @description: 发送指令
 * @param {uint8_t} reg 指定寄存器
 * @param {uint16_t} cmd 指令内容
 * @return {*}
 *************************************************************************************/
void VS_WR_Cmd(uint8_t reg, uint16_t cmd)
{
    VS_DQ_Wait();   // 等待空闲
    VS_SPI_SpeedLow();  // 低速
    VS_XDCS_Set();
    VS_XCS_Clr();
	VS_SPI_ReadWriteByte(VS_WRITE_COMMAND);//发送VS10XX的写命令
	VS_SPI_ReadWriteByte(reg); 	//地址
	VS_SPI_ReadWriteByte(cmd>>8); 	//发送高八位
	VS_SPI_ReadWriteByte(cmd);	 	//第八位
    VS_XCS_Set();
    VS_SPI_SpeedHigh(); // 高速
}

/*************************************************************************************
 * @description: 写入数据
 * @param {uint8_t} data 待写数据
 * @return {*}
 *************************************************************************************/
void VS_WR_Data(uint8_t data)
{
    VS_SPI_SpeedHigh();
    VS_XDCS_Clr();
	VS_SPI_ReadWriteByte(data);
    VS_XDCS_Set();
}

/*************************************************************************************
 * @description: 读取寄存器 
 * @param {uint8_t} reg
 * @return {*}
 *************************************************************************************/
uint16_t VS_RD_Reg(uint8_t reg)
{
    uint16_t temp = 0;
    VS_DQ_Wait();   // 等待
    VS_SPI_SpeedLow();  // 低速
    VS_XDCS_Set();
    VS_XCS_Clr();
    VS_SPI_ReadWriteByte(VS_READ_COMMAND);  // 读命令
    VS_SPI_ReadWriteByte(reg);
    temp = VS_SPI_ReadWriteByte(0xff);
    temp = temp << 8;
    temp += VS_SPI_ReadWriteByte(0xff);
    VS_XCS_Set();
    VS_SPI_SpeedHigh();
    return temp;
}

/*************************************************************************************
 * @description: 读取RAM
 * @param {uint16_t} addr 待读地址
 * @return {*}
 *************************************************************************************/
uint16_t VS_WRAM_Read(uint16_t addr)
{
    uint16_t res;
    VS_WR_Cmd(SPI_WRAMADDR, addr);
    res = VS_RD_Reg(SPI_WRAM);
    return res;
}

/*************************************************************************************
 * @description: 写RAM
 * @param {uint16_t} addr 待写地址
 * @param {uint16_t} val 写的值
 * @return {*}
 *************************************************************************************/
void VS_WRAM_Write(uint16_t addr, uint16_t val)
{
    VS_WR_Cmd(SPI_WRAMADDR, addr);  // 写ram地址
    VS_DQ_Wait();
    VS_WR_Cmd(SPI_WRAM, val);
}

/*************************************************************************************
 * @description: 设置播放速度
 * @param {uint8_t} t 播放速度：0，1：正常速度，2：2倍速，3：3倍速，4：4倍速，以此类推
 * @return {*}
 *************************************************************************************/
void VS_Set_Speed(uint8_t t)
{
	VS_WRAM_Write(0X1E04,t);		//写入播放速度 
}

//FOR WAV HEAD0 :0X7761 HEAD1:0X7665    
//FOR MIDI HEAD0 :other info HEAD1:0X4D54
//FOR WMA HEAD0 :data speed HEAD1:0X574D
//FOR MP3 HEAD0 :data speed HEAD1:ID
//比特率预定值,阶层III
const uint16_t bitrate[2][16]=
{ 
{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0}, 
{0,32,40,48,56,64,80,96,112,128,160,192,224,256,320,0}
};
/*************************************************************************************
 * @description:获取码率 
 * @param {*}
 * @return {uint16_t} 码率
 *************************************************************************************/
uint16_t VS_Get_HeadInfo(void)
{
	unsigned int HEAD0;
	unsigned int HEAD1;  
 	HEAD0=VS_RD_Reg(SPI_HDAT0); 
    HEAD1=VS_RD_Reg(SPI_HDAT1);
    switch(HEAD1)
    {        
        case 0x7665://WAV格式
        case 0X4D54://MIDI格式 
		case 0X4154://AAC_ADTS
		case 0X4144://AAC_ADIF
		case 0X4D34://AAC_MP4/M4A
		case 0X4F67://OGG
        case 0X574D://WMA格式
		case 0X664C://FLAC格式
        {
			////printf("HEAD0:%d\n",HEAD0);
            HEAD1=HEAD0*2/25;//相当于*8/100
            if((HEAD1%10)>5)return HEAD1/10+1;//对小数点第一位四舍五入
            else return HEAD1/10;
        }
        default://MP3格式,仅做了阶层III的表
        {
            HEAD1>>=3;
            HEAD1=HEAD1&0x03; 
            if(HEAD1==3)HEAD1=1;
            else HEAD1=0;
            return bitrate[HEAD1][HEAD0>>12];
        }
    }  
}

/*************************************************************************************
 * @description: 平均字节数
 * @param {*}
 * @return {uint32_t} 平均字节速度
 *************************************************************************************/
uint32_t VS_Get_ByteRate(void)
{
	return VS_WRAM_Read(0X1E05);//平均位速
}

/*************************************************************************************
 * @description: 得到需要填充的数字
 * @param {*}
 * @return {uint16_t} 需要填充的数字
 *************************************************************************************/
uint16_t VS_Get_EndFillByte(void)
{
	return VS_WRAM_Read(0X1E06);//填充字节
}

/*************************************************************************************
 * @description: 发送一次音频数据
 * @param {*} 固定为32字节
 * @return {uint8_t} 0:发送成功， 1，：缺少数据，本次发送未成功
 *************************************************************************************/
uint8_t VS_Send_MusicData(uint8_t* buf)
{
	uint8_t n;
	if(VS_DQ_Read() != GPIO_PIN_RESET)  //送数据给VS10XX
	{			   	 
		VS_XDCS_Clr();
        for(n=0;n<32;n++)
		{
			VS_SPI_ReadWriteByte(buf[n]);	 			
		}
		VS_XDCS_Set(); 				   
	}else return 1;
	return 0;//成功发送了
}

/*************************************************************************************
 * @description: 切歌
 * @param {*}
 * @return {*}
 *************************************************************************************/
void VS_Restart_Play(void)
{
	uint16_t temp;
	uint16_t i;
	uint8_t n;	  
	uint8_t vsbuf[32];
	for(n=0;n<32;n++)vsbuf[n]=0;//清零
	temp=VS_RD_Reg(SPI_MODE);	//读取SPI_MODE的内容
	temp|=1<<3;					//设置SM_CANCEL位
	temp|=1<<2;					//设置SM_LAYER12位,允许播放MP1,MP2
	VS_WR_Cmd(SPI_MODE,temp);	//设置取消当前解码指令
	for(i=0;i<2048;)			//发送2048个0,期间读取SM_CANCEL位.如果为0,则表示已经取消了当前解码
	{
		if(VS_Send_MusicData(vsbuf)==0)//每发送32个字节后检测一次
		{
			i+=32;						//发送了32个字节
   			temp=VS_RD_Reg(SPI_MODE);	//读取SPI_MODE的内容
 			if((temp&(1<<3))==0)break;	//成功取消了
		}	
	}
	if(i<2048)//SM_CANCEL正常
	{
		temp=VS_Get_EndFillByte()&0xff;//读取填充字节
		for(n=0;n<32;n++)vsbuf[n]=temp;//填充字节放入数组
		for(i=0;i<2052;)
		{
			if(VS_Send_MusicData(vsbuf)==0)i+=32;//填充	  
		}   	
	}else VS_Soft_Reset();  	//SM_CANCEL不成功,坏情况,需要软复位 	  
	temp=VS_RD_Reg(SPI_HDAT0); 
    temp+=VS_RD_Reg(SPI_HDAT1);
	if(temp)					//软复位,还是没有成功取消,放杀手锏,硬复位
	{
		VS_HD_Reset();		   	//硬复位
		VS_Soft_Reset();  		//软复位 
	} 
}

/*************************************************************************************
 * @description: 重设解码时间 
 * @param {*}
 * @return {*}
 *************************************************************************************/
void VS_Reset_DecodeTime(void)
{
	VS_WR_Cmd(SPI_DECODE_TIME,0x0000);
	VS_WR_Cmd(SPI_DECODE_TIME,0x0000);//操作两次
}

/*************************************************************************************
 * @description: 得到mp3播放时间
 * @param {*}
 * @return {uint16_t} 解码时长
 *************************************************************************************/
uint16_t VS_Get_DecodeTime(void)
{
	uint16_t dt=0;	 
	dt=VS_RD_Reg(SPI_DECODE_TIME);      
 	return dt;
}

/*************************************************************************************
 * @description: 装载patch
 * @param {uint16_t} *patch patch首地址
 * @param {uint16_t} len patch长度
 * @return {*}
 *************************************************************************************/
void VS_Load_Patch(uint16_t *patch,uint16_t len)
{
	uint16_t i; 
	uint16_t addr, n, val; 	  			   
	for(i=0;i<len;) 
	{ 
		addr = patch[i++]; 
		n    = patch[i++]; 
		if(n & 0x8000U) //RLE run, replicate n samples 
		{ 
			n  &= 0x7FFF; 
			val = patch[i++]; 
			while(n--)VS_WR_Cmd(addr, val);  
		}else //copy run, copy n sample 
		{ 
			while(n--) 
			{ 
				val = patch[i++]; 
				VS_WR_Cmd(addr, val); 
			} 
		} 
	} 	
}


/*************************************************************************************
 * @description: 设定音量
 * @param {uint8_t} volx 音量大小（0~254)
 * @return {*}
 *************************************************************************************/
void VS_Set_Vol(uint8_t volx)
{
    uint16_t volt=0; 			//暂存音量值
    volt=254-volx;			//取反一下,得到最大值,表示最大的表示 
	volt<<=8;
    volt+=254-volx;			//得到音量设置后大小
    VS_WR_Cmd(SPI_VOL,volt);//设音量 
}


/*************************************************************************************
 * @description: 设置高低音控制
 * @param {uint8_t} bfreq   低频上限频率	2~15(单位:10Hz)
 * @param {uint8_t} bass    低频增益		0~15(单位:1dB)
 * @param {uint8_t} tfreq   高频下限频率 	1~15(单位:Khz)              
 * @param {uint8_t} treble  高频增益  	 	0~15(单位:1.5dB,小于9的时候为负数)
 * @return {*}
 *************************************************************************************/
void VS_Set_Bass(uint8_t bfreq,uint8_t bass,uint8_t tfreq,uint8_t treble)
{
    uint16_t bass_set=0; //暂存音调寄存器值
    signed char temp=0;   	 
	if(treble==0)temp=0;	   		//变换
	else if(treble>8)temp=treble-8;
 	else temp=treble-9;  
	bass_set=temp&0X0F;				//高音设定
	bass_set<<=4;
	bass_set+=tfreq&0xf;			//高音下限频率
	bass_set<<=4;
	bass_set+=bass&0xf;				//低音设定
	bass_set<<=4;
	bass_set+=bfreq&0xf;			//低音上限    
	VS_WR_Cmd(SPI_BASS,bass_set);	//BASS 
}


/*************************************************************************************
 * @description: 设定音效
 * @param {uint8_t} eft 0,关闭;1,最小;2,中等;3,最大
 * @return {*}
 *************************************************************************************/
void VS_Set_Effect(uint8_t eft)
{
	uint16_t temp;	 
	temp=VS_RD_Reg(SPI_MODE);	//读取SPI_MODE的内容
	if(eft&0X01)temp|=1<<4;		//设定LO
	else temp&=~(1<<5);			//取消LO
	if(eft&0X02)temp|=1<<7;		//设定HO
	else temp&=~(1<<7);			//取消HO						   
	VS_WR_Cmd(SPI_MODE,temp);	//设定模式 
}

/*************************************************************************************
 * @description: 板载喇叭开/关设置
 * @param {uint8_t} sw 0:关闭，1：开启
 * @return {*}
 *************************************************************************************/
void VS_SPK_Set(uint8_t sw)
{
	VS_WRAM_Write(GPIO_DDR,1<<4);	//VS1053的GPIO4设置成输出
	VS_WRAM_Write(GPIO_ODATA,sw<<4);//控制VS1053的GPIO4输出值(0/1)
}

/*************************************************************************************
 * @description:设置音量、音效等 
 * @param {*}
 * @return {*}
 *************************************************************************************/
void VS_Set_All(void)
{
	VS_Set_Vol(vsset.mvol);			//设置音量
	VS_Set_Bass(vsset.bflimit,vsset.bass,vsset.tflimit,vsset.treble);  
	VS_Set_Effect(vsset.effect);	//设置空间效果
	VS_SPK_Set(vsset.speakersw);	//控制板载喇叭状态 
}